<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGL GPU Stress Test</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin: 0; padding: 0; background: #000; height: 100%; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #info { position: fixed; top: 8px; left: 8px; color: #8f8; font: 12px monospace; opacity: 0.8; }
  </style>
  <!-- Self-contained WebGL page to induce GPU load without external deps -->
  <!-- Close the tab/window when you're done testing. -->
</head>
<body>
  <div id="info">WebGL running... this should exercise your GPU. Close when done.</div>
  <canvas id="c"></canvas>
  <script>
  (function(){
    const canvas = document.getElementById('c');
    function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
    addEventListener('resize', resize); resize();
    const gl = canvas.getContext('webgl', { antialias: false, powerPreference: 'high-performance' })
           || canvas.getContext('experimental-webgl');
    if(!gl){ document.body.innerHTML = '<div style="color:#f88;font:14px monospace;padding:1rem">WebGL not available. Enable GPU acceleration and restart your browser.</div>'; return; }

    const vs = `
      attribute vec2 p;
      void main(){ gl_Position = vec4(p, 0.0, 1.0); }
    `;
    const fs = `
      precision highp float;
      uniform vec2 r; // resolution
      uniform float t; // time
      void main(){
        vec2 uv = (gl_FragCoord.xy / r) - 0.5;
        float acc = 0.0;
        // Do a fair amount of ALU work per pixel
        for (int i = 1; i <= 60; ++i) {
          float fi = float(i);
          acc += sin(fi*9.7*uv.x + t*0.37) * cos(fi*10.1*uv.y - t*0.53);
          acc += sin(fi*7.3*(uv.x+uv.y) + t*0.21);
        }
        float c = 0.5 + 0.5 * sin(acc*0.05 + t*0.7);
        gl_FragColor = vec4(vec3(c), 1.0);
      }
    `;

    function sh(type, src){
      const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
      return s;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
    gl.useProgram(prog);

    const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1, -1, 3, -1, -1, 3 ]), gl.STATIC_DRAW);
    const loc = gl.getAttribLocation(prog, 'p');
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

    const uR = gl.getUniformLocation(prog, 'r');
    const uT = gl.getUniformLocation(prog, 't');
    function frame(t){
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.uniform2f(uR, canvas.width, canvas.height);
      gl.uniform1f(uT, t*0.001);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
 </body>
 </html>
